<h2>Task</h2>
<li>Создать любой gradle проект</li>
<li>Проект должен быть совместим с java 17</li>
<li>Придерживаться GitFlow: master -> develop -> feature/fix</li>
<li>Разработать библиотеку, которая будет формировать на основе Java класса json и обратно</li>
<li>Использовать рефлексию</li>
<li>Предусмотреть возможную вложенность объектов (рекурсия), смотрите приложение I</li>
<li>Покрыть код unit tests (можно использовать jackson/gson)</li>
<li>Использовать lombok</li>


<h3>Реализация </h3>
<p>Идеально не вышло, но многое работает</p>
<p>Первоначально сделал кастомный сериализатор, исходя из принятого тестового объекта с вложенностью уровня серьезной матрешки: объект, в нем объект, в оном мапа со стрингой и листом из третьего объекта.</p>
<p>Казалось, что может пойти не так?</p>
<p>Многое!</p>
<p>Стоит заметить, при хардкоде на конкретный объект все сработало. Особенно внимательных развеселит BaseClassJsonDeserializer</p>
<p>Прочитав условие еще раз (ВНИМАТЕЛЬНО ЧИТАЙ УСЛОВИЕ! (с)), начал от тестов классов с разными объектами и разной вложенности</p>
<p>Подправил сериализатор, до определенной вложенности работает без проблем. Затормозил в моменте доступа к приватным полям сторонних библиотек, но методом гуглаОверФлоу и это самое, решил, подкинув в итоге в тест-конфиг VM options - jvmArgs(['--add-opens', 'java.base/java.util=ALL-UNNAMED']). Пробовал через статическую инициализацию полей объекта, но тогда параметрические тесты слетают, а мы же TDD и дела там еще есть по дому.</p>
<p>В десериализаторе уперся в парсер.</p>